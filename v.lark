///////////////////////////////////////////////////
// V Grammar
///////////////////////////////////////////////////
// This is the grammar used by the parser to parse 
// the V code. I am not sure how close it is to 
// the official V compiler but that is what made
// the most sense to me
///////////////////////////////////////////////////

///////////////////////////////////////////////////
// module scope stuff 
///////////////////////////////////////////////////

start: _module_item*

_module_item: fn_decl
            | struct_decl
            | module_decl
            | _NEWLINE

// Misc

module_decl: "module" NAME ("." NAME)* _NEWLINE

// Function declaration

fn_decl: maybe_pub "fn" NAME "(" fn_params ")" fn_return "{" stmt_list "}" _NEWLINE
fn_params: [fn_param ("," fn_param)*]
fn_param: NAME maybe_mut type_decl | NAME
fn_return: [maybe_mut type_decl | "(" maybe_mut type_decl ("," maybe_mut type_decl)+ ")"]

// Struct declaration
// TODO: support for changing mutability of fields

struct_decl: "struct" NAME "{" _NEWLINE? embedded_struct_field struct_fields "}"
struct_fields: struct_field*
struct_field: NAME type_decl _NEWLINE
embedded_struct_field: (maybe_mut NAME _NEWLINE)?

///////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////

// TODO: Add back C based for loops
// TODO: | "for" (maybe_var_decl|stmt_assignment) ";" _expr ";" (_expr | stmt_assignment) "{" stmt_list "}" -> stmt_for

?stmt: _expr _NEWLINE -> stmt_expr
     | "return" [_expr ("," _expr)*] _NEWLINE -> stmt_return
     | "assert" _expr _NEWLINE -> stmt_assert
     | _expr _op_assignment _expr _NEWLINE -> stmt_op_assign
     | "for" NAME "in" _expr "{" stmt_list "}" -> stmt_foreach
     | "for" NAME "," NAME "in" _expr "{" stmt_list "}" -> stmt_foreach_indexed
     | "for" "{" stmt_list "}"-> stmt_forever
     | "break" -> stmt_break
     | "continue" -> stmt_continue
     | stmt_var_decl _NEWLINE
     | stmt_assignment _NEWLINE
     | stmt_if
     | _NEWLINE

stmt_var_decl: var_decl_names ":=" _expr
!maybe_var_decl: stmt_var_decl?

?stmt_assignment: _expr "=" _expr -> stmt_assign

stmt_if: "if" _expr "{" stmt_list "}" (stmt_else | _NEWLINE)
?stmt_else: "else" "{" stmt_list "}" _NEWLINE -> stmt_else
          | "else" stmt_if -> stmt_else_if

var_decl: maybe_mut NAME
var_decl_names: var_decl ("," var_decl)*


!_op_assignment: ("+="|"-="|"*="|"/="|"%="|"<<="|">>="|"|="|"&="|"^=")

stmt_list: stmt*

///////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////

//************************************
// the full expression precendence
//************************************

_expr: expr_postfix

?expr_postfix: expr_unary _op_postfix -> expr_postfix
             | expr_unary

?expr_unary: _op_unary expr_multiplicative -> expr_unary
           | expr_multiplicative

?expr_multiplicative: expr_additive _op_multiplicative expr_additive -> expr_binary
                    | expr_additive

?expr_additive: expr_shift _op_additive expr_shift -> expr_binary
              | expr_shift

?expr_shift: expr_relational _op_shift expr_relational -> expr_binary
           | expr_relational

?expr_relational: expr_equality _op_relational expr_equality -> expr_binary
                | expr_equality

?expr_equality: expr_bitwise_and _op_equality expr_bitwise_and -> expr_binary
              | expr_bitwise_and

?expr_bitwise_and: expr_bitwise_xor _op_bitwise_and expr_bitwise_xor -> expr_binary
                 | expr_bitwise_xor

?expr_bitwise_xor: expr_bitwise_or _op_bitwise_xor expr_bitwise_or -> expr_binary
                 | expr_bitwise_or

?expr_bitwise_or:  expr_logical_and _op_bitwise_or expr_logical_and -> expr_binary
                | expr_logical_and

?expr_logical_and: expr_logical_or _op_logical_and expr_logical_or -> expr_binary
                 | expr_logical_or

?expr_logical_or: expr_others _op_logical_or expr_others -> expr_binary
                | expr_others

// all the operators
!_op_postfix: ("++"|"--")
!_op_unary: ("-"|"!"|"++"|"--")
!_op_multiplicative: ("*"|"/"|"%")
!_op_additive: ("+"|"-")
!_op_shift: ("<<"|">>")
!_op_relational: (">"|">="|"<="|"<")
!_op_equality: ("=="|"!=")
!_op_bitwise_xor: "^"
!_op_bitwise_and: "&"
!_op_bitwise_or: "|"
!_op_logical_and: "&&"
!_op_logical_or: "||"

?expr_others: _expr "." NAME -> expr_member_access
            | _expr "(" (maybe_mut _expr ("," maybe_mut _expr)*)? ")" -> expr_fn_call
            | _expr "[" _expr "]" -> expr_index
            | expr_literals

?expr_literals: "(" _expr ")"
          | "none" -> const_none
          | "false" -> const_false
          | "true" -> const_true
          | string
          | number
          | ident
          | struct_literal
          | struct_literal_named
          | array_literal
          | array_literal_uninit

///////////////////////////////////////////////////
// Literals
///////////////////////////////////////////////////

// Struct literal types
// MyStruct{1,2,3}
struct_literal: maybe_ref NAME "{" (_expr ("," _expr)*)? "}"
// MyStruct{a: 1, b: 2, c: 3}
struct_literal_named: maybe_ref NAME "{" struct_literal_named_item ("," struct_literal_named_item)* "}"
// MyStruct{ old | b: 3, c: 4 }
// struct_literal_modify: maybe_ref NAME "{" _expr "|" struct_literal_named_item ("," struct_literal_named_item)* "}"
struct_literal_named_item: NAME ":" _expr

// array literal
array_literal: "[" _expr ("," _expr)* "]"
array_literal_uninit: "[" _expr "]" type_decl

number: DEC_NUMBER
string: STRING
ident: NAME

///////////////////////////////////////////////////
// type declarations
///////////////////////////////////////////////////

?type_decl: type_ident
          | type_array
          | type_map
          | type_ref
          | type_opt

type_array: "[" "]" type_decl
type_map: "map" "[" type_decl "]" type_decl
type_ref: "&" type_decl
type_opt: "?" type_decl
type_ident: NAME

!maybe_pub: "pub"?
!maybe_mut: "mut"?
!maybe_ref: "&"?

///////////////////////////////////////////////////
// basic stuff
///////////////////////////////////////////////////

STRING : /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
NAME: /[a-zA-Z_]\w*/
DEC_NUMBER: /0|[1-9]\d*/i
_NEWLINE: /\n+/

%ignore /[\t \f]+/
