///////////////////////////////////////////////////
// V Grammar
///////////////////////////////////////////////////
// This is the grammar used by the parser to parse 
// the V code. I am not sure how close it is to 
// the official V compiler but that is what made
// the most sense to me
///////////////////////////////////////////////////

///////////////////////////////////////////////////
// module scope stuff 
///////////////////////////////////////////////////

start: _module_item*

_module_item: fn_decl
            | struct_decl
            | module_decl
            | _NEWLINE
//            | type_alias_decl

// Misc

module_decl: "module" NAME ("." NAME)* _NEWLINE
//type_alias_decl: "type" NAME type_decl _NEWLINE

// Function declaration

fn_decl: maybe_pub "fn" NAME "(" fn_params ")" fn_return "{" stmt_list "}" _NEWLINE
fn_params: [fn_param ("," fn_param)*]
fn_param: NAME type_decl | NAME
fn_return: [type_decl | "(" type_decl ("," type_decl)+ ")"]

// Struct declaration

struct_decl: "struct" NAME "{" _NEWLINE? embedded_struct_field struct_fields "}"
struct_fields: struct_field*
struct_field: NAME type_decl _NEWLINE
embedded_struct_field: (maybe_mut NAME _NEWLINE)?

///////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////

?stmt: expr _NEWLINE -> stmt_expr
     | "return" [expr ("," expr)*] _NEWLINE -> stmt_return
     | var_decl_names ":=" expr _NEWLINE -> stmt_var_decl
     | "assert" expr _NEWLINE -> stmt_assert
     | stmt_if
     | _NEWLINE

stmt_if: "if" expr "{" stmt_list "}" (stmt_else | _NEWLINE)
?stmt_else: "else" "{" stmt_list "}" _NEWLINE -> stmt_else
          | "else" stmt_if -> stmt_else_if

var_decl: maybe_mut NAME
var_decl_names: var_decl ("," var_decl)*

stmt_list: stmt*

///////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////

//************************************
// the full expression precendence
//************************************

?expr: expr "." NAME -> expr_member_access
     | expr "(" (expr ("," expr)*)? ")" -> expr_fn_call
     | expr "[" expr "]" -> expr_index
     | expr_postfix

?expr_postfix:
             | expr_unary _op_postfix -> expr_postfix
             | expr_unary

?expr_unary: _op_unary expr_multiplicative -> expr_unary
           | expr_multiplicative

?expr_multiplicative: expr_additive _op_multiplicative expr_additive -> expr_binary
                    | expr_additive

?expr_additive: expr_shift _op_additive expr_shift -> expr_binary
              | expr_shift

?expr_shift: expr_relational _op_shift expr_relational -> expr_binary
           | expr_relational

?expr_relational: expr_equality _op_relational expr_equality -> expr_binary
                | expr_equality

?expr_equality: expr_bitwise_and _op_equality expr_bitwise_and -> expr_binary
              | expr_bitwise_and

?expr_bitwise_and: expr_bitwise_xor _op_bitwise_and expr_bitwise_xor -> expr_binary
                 | expr_bitwise_xor

?expr_bitwise_xor: expr_bitwise_or _op_bitwise_xor expr_bitwise_or -> expr_binary
                 | expr_bitwise_or

?expr_bitwise_or:  expr_logical_and _op_bitwise_or expr_logical_and -> expr_binary
                | expr_logical_and

?expr_logical_and: expr_logical_or _op_logical_and expr_logical_or -> expr_binary
                 | expr_logical_or

?expr_logical_or: expr_atom _op_logical_or expr_atom -> expr_binary
                | expr_atom

// all the operators
!_op_postfix: ("++"|"--")
!_op_unary: ("-"|"!"|"++"|"--")
!_op_multiplicative: ("*"|"/"|"%")
!_op_additive: ("+"|"-")
!_op_shift: ("<<"|">>")
!_op_relational: (">"|">="|"<="|"<")
!_op_equality: ("=="|"!=")
!_op_bitwise_xor: "^"
!_op_bitwise_and: "&"
!_op_bitwise_or: "|"
!_op_logical_and: "&&"
!_op_logical_or: "||"

?expr_atom: "(" expr ")"
          | "none" -> const_none
          | "false" -> const_false
          | "true" -> const_true
          | string
          | number
          | ident
          | struct_literal
          | struct_literal_named

///////////////////////////////////////////////////
// Literals
///////////////////////////////////////////////////

// Struct literal types
// MyStruct{1,2,3}
struct_literal: maybe_mut maybe_ref NAME "{" (expr ("," expr)*)? "}"
// MyStruct{a: 1, b: 2, c: 3}
struct_literal_named: maybe_mut maybe_ref NAME "{" struct_literal_named_item ("," struct_literal_named_item)* "}"
// MyStruct{ old | b: 3, c: 4 }
// struct_literal_modify: maybe_mut maybe_ref NAME "{" expr "|" struct_literal_named_item ("," struct_literal_named_item)* "}"
struct_literal_named_item: NAME ":" expr

number: DEC_NUMBER
string: STRING
ident: NAME

///////////////////////////////////////////////////
// type declarations
///////////////////////////////////////////////////

?type_decl: type_ident
          | type_array
          | type_map
          | type_ref
          | type_opt

type_array: maybe_mut "[" "]" type_decl
type_map: maybe_mut "map" "[" type_decl "]" type_decl
type_ref: maybe_mut "&" type_decl
type_opt: maybe_mut "?" type_decl
type_ident: maybe_mut NAME

!maybe_pub: "pub"?
!maybe_mut: "mut"?
!maybe_ref: "&"?

///////////////////////////////////////////////////
// basic stuff
///////////////////////////////////////////////////

STRING : /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
NAME: /[a-zA-Z_]\w*/
DEC_NUMBER: /0|[1-9]\d*/i
_NEWLINE: /\n+/

%ignore /[\t \f]+/
